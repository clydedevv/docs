---
sidebar_position: 6
---

# API Reference

## gRPC Endpoints

### Query Service

The Global Fee module provides the following gRPC query endpoints:

#### Params

Get current module parameters.

**Endpoint:** `/neutron.globalfee.Query/Params`

**Request:**
```protobuf
message QueryParamsRequest {}
```

**Response:**
```protobuf
message QueryParamsResponse {
  Params params = 1 [(gogoproto.nullable) = false];
}
```

**Example:**
```bash
grpcurl -plaintext localhost:9090 neutron.globalfee.Query/Params
```

**Response:**
```json
{
  "params": {
    "minimum_gas_prices": [
      {
        "denom": "untrn",
        "amount": "0.025000000000000000"
      }
    ],
    "bypass_min_fee_msg_types": [
      "/cosmos.gov.v1beta1.MsgVote",
      "/cosmos.gov.v1beta1.MsgVoteWeighted"
    ],
    "max_total_bypass_min_fee_msg_gas_usage": "1000000"
  }
}
```

## REST API Endpoints

### Query Endpoints

#### Get Parameters

**Endpoint:** `GET /neutron/globalfee/v1beta1/params`

**Description:** Retrieve current Global Fee module parameters

**Response:**
```json
{
  "params": {
    "minimum_gas_prices": [
      {
        "denom": "untrn",
        "amount": "0.025000000000000000"
      },
      {
        "denom": "ibc/C4CFF46FD6DE35CA4CF4CE031E643C8FDC9BA4B99AE598E9B0ED98FE3A2319F9",
        "amount": "0.001000000000000000"
      }
    ],
    "bypass_min_fee_msg_types": [
      "/cosmos.gov.v1beta1.MsgVote",
      "/cosmos.gov.v1beta1.MsgVoteWeighted",
      "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
      "/cosmos.staking.v1beta1.MsgDelegate"
    ],
    "max_total_bypass_min_fee_msg_gas_usage": "1000000"
  }
}
```

**cURL Example:**
```bash
curl -X GET "https://rest.neutron.org/neutron/globalfee/v1beta1/params" \
  -H "accept: application/json"
```

## Transaction Messages

### MsgUpdateParams

Update Global Fee module parameters (governance only).

**Type:** `/neutron.globalfee.MsgUpdateParams`

**Structure:**
```protobuf
message MsgUpdateParams {
  // authority is the address that controls the module 
  // (defaults to x/gov unless overwritten).
  string authority = 1;

  // params defines the x/globalfee parameters to update.
  Params params = 2 [(gogoproto.nullable) = false];
}
```

**Response:**
```protobuf
message MsgUpdateParamsResponse {}
```

<Warning>
This message can only be executed through governance proposals. Direct execution by users will fail.
</Warning>

## Client Libraries

### Go Client

```go
package main

import (
    "context"
    "fmt"
    
    "google.golang.org/grpc"
    "github.com/neutron-org/neutron/v6/x/globalfee/types"
)

func queryGlobalFeeParams(grpcConn *grpc.ClientConn) error {
    client := types.NewQueryClient(grpcConn)
    
    resp, err := client.Params(context.Background(), &types.QueryParamsRequest{})
    if err != nil {
        return err
    }
    
    fmt.Printf("Minimum gas prices: %v\n", resp.Params.MinimumGasPrices)
    fmt.Printf("Bypass message types: %v\n", resp.Params.BypassMinFeeMsgTypes)
    fmt.Printf("Max bypass gas usage: %d\n", resp.Params.MaxTotalBypassMinFeeMsgGasUsage)
    
    return nil
}
```

### JavaScript/TypeScript Client

```typescript
import { QueryClient } from "@cosmjs/stargate";

interface GlobalFeeParams {
  minimum_gas_prices: Array<{
    denom: string;
    amount: string;
  }>;
  bypass_min_fee_msg_types: string[];
  max_total_bypass_min_fee_msg_gas_usage: string;
}

async function queryGlobalFeeParams(client: QueryClient): Promise<GlobalFeeParams> {
  const response = await client.queryAbci("/neutron.globalfee.Query/Params", new Uint8Array());
  
  // Decode protobuf response
  const decoded = /* decode response */;
  
  return decoded.params;
}

// REST API alternative
async function queryGlobalFeeParamsRest(): Promise<GlobalFeeParams> {
  const response = await fetch('https://rest.neutron.org/neutron/globalfee/v1beta1/params');
  const data = await response.json();
  
  return data.params;
}
```

### Python Client

```python
import requests
from typing import List, Dict, Any

class GlobalFeeClient:
    def __init__(self, rest_endpoint: str = "https://rest.neutron.org"):
        self.rest_endpoint = rest_endpoint
    
    def get_params(self) -> Dict[str, Any]:
        """Get Global Fee module parameters."""
        url = f"{self.rest_endpoint}/neutron/globalfee/v1beta1/params"
        response = requests.get(url)
        response.raise_for_status()
        
        return response.json()["params"]
    
    def get_minimum_gas_prices(self) -> List[Dict[str, str]]:
        """Get minimum gas prices."""
        params = self.get_params()
        return params["minimum_gas_prices"]
    
    def get_bypass_message_types(self) -> List[str]:
        """Get bypass message types."""
        params = self.get_params()
        return params["bypass_min_fee_msg_types"]
    
    def calculate_minimum_fee(self, gas_used: int, denom: str = "untrn") -> int:
        """Calculate minimum fee for given gas usage."""
        gas_prices = self.get_minimum_gas_prices()
        
        for price in gas_prices:
            if price["denom"] == denom:
                gas_price = float(price["amount"])
                return int(gas_used * gas_price)
        
        raise ValueError(f"No gas price found for denom {denom}")

# Usage
client = GlobalFeeClient()
params = client.get_params()
print(f"Minimum gas prices: {params['minimum_gas_prices']}")

# Calculate fee
fee = client.calculate_minimum_fee(200000, "untrn")
print(f"Minimum fee for 200k gas: {fee}untrn")
```

## CLI Commands

### Query Commands

#### Query Parameters

```bash
neutrond query globalfee params
```

**Output:**
```yaml
bypass_min_fee_msg_types:
- /cosmos.gov.v1beta1.MsgVote
- /cosmos.gov.v1beta1.MsgVoteWeighted
max_total_bypass_min_fee_msg_gas_usage: "1000000"
minimum_gas_prices:
- amount: "0.025000000000000000"
  denom: untrn
```

### Transaction Commands

Global Fee module has no direct transaction commands. Parameter updates must be done through governance proposals.

## Error Responses

### Common Error Codes

#### Insufficient Fee
```json
{
  "error": "insufficient fee: got 1000untrn, required 5000untrn: insufficient fee",
  "code": 13,
  "message": "insufficient fee: got 1000untrn, required 5000untrn: insufficient fee"
}
```

#### Invalid Parameters
```json
{
  "error": "invalid request: duplicate denomination untrn in minimum gas prices",
  "code": 3,
  "message": "invalid request: duplicate denomination untrn in minimum gas prices"
}
```

#### Unauthorized
```json
{
  "error": "unauthorized: expected authority neutron10d07y265gmmuvt4z0w9aw880jnsr700juxf95n, got neutron1...",
  "code": 4,
  "message": "unauthorized: expected authority neutron10d07y265gmmuvt4z0w9aw880jnsr700juxf95n, got neutron1..."
}
```

## Integration Examples

### Fee Validation

```javascript
function validateTransactionFee(tx, globalFeeParams) {
  const { minimum_gas_prices, bypass_min_fee_msg_types, max_total_bypass_min_fee_msg_gas_usage } = globalFeeParams;
  
  // Check if all messages are bypass-eligible
  const allBypassEligible = tx.messages.every(msg => 
    bypass_min_fee_msg_types.includes(msg.type_url)
  );
  
  if (allBypassEligible && tx.gas_used <= max_total_bypass_min_fee_msg_gas_usage) {
    return true; // Fee bypass applies
  }
  
  // Calculate required fees
  for (const gasPrice of minimum_gas_prices) {
    const requiredAmount = Math.ceil(tx.gas_used * parseFloat(gasPrice.amount));
    const paidAmount = tx.fees.find(fee => fee.denom === gasPrice.denom)?.amount || 0;
    
    if (paidAmount >= requiredAmount) {
      return true; // Sufficient fee paid
    }
  }
  
  return false; // Insufficient fee
}
```

### Dynamic Fee Calculation

```go
func CalculateDynamicFee(gasUsed uint64, params types.Params) sdk.Coins {
    var fees sdk.Coins
    
    for _, gasPrice := range params.MinimumGasPrices {
        feeAmount := gasPrice.Amount.MulInt64(int64(gasUsed)).Ceil().TruncateInt()
        if feeAmount.IsPositive() {
            fees = fees.Add(sdk.NewCoin(gasPrice.Denom, feeAmount))
        }
    }
    
    return fees
}
``` 