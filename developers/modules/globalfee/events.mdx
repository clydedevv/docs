---
sidebar_position: 7
---

# Events

The Global Fee module emits events for parameter updates and fee enforcement actions.

## Parameter Update Events

### EventUpdateParams

Emitted when module parameters are updated through governance.

**Type:** `neutron.globalfee.EventUpdateParams`

**Attributes:**
- `authority` (string): Address that executed the parameter update
- `params` (Params): New parameter values

**Example:**
```json
{
  "type": "neutron.globalfee.EventUpdateParams",
  "attributes": [
    {
      "key": "authority",
      "value": "neutron10d07y265gmmuvt4z0w9aw880jnsr700juxf95n"
    },
    {
      "key": "params",
      "value": "{\"minimum_gas_prices\":[{\"denom\":\"untrn\",\"amount\":\"0.050000000000000000\"}],\"bypass_min_fee_msg_types\":[\"/cosmos.gov.v1beta1.MsgVote\"],\"max_total_bypass_min_fee_msg_gas_usage\":\"1000000\"}"
    }
  ]
}
```

## Fee Enforcement Events

### EventFeeBypass

Emitted when a transaction bypasses minimum fee requirements.

**Type:** `neutron.globalfee.EventFeeBypass`

**Attributes:**
- `tx_hash` (string): Transaction hash
- `gas_used` (uint64): Total gas consumed
- `message_types` ([]string): Message types in the transaction
- `bypass_reason` (string): Reason for fee bypass

**Example:**
```json
{
  "type": "neutron.globalfee.EventFeeBypass",
  "attributes": [
    {
      "key": "tx_hash",
      "value": "A1B2C3D4E5F6789..."
    },
    {
      "key": "gas_used",
      "value": "150000"
    },
    {
      "key": "message_types",
      "value": "[\"/cosmos.gov.v1beta1.MsgVote\"]"
    },
    {
      "key": "bypass_reason",
      "value": "governance_message"
    }
  ]
}
```

### EventInsufficientFee

Emitted when a transaction is rejected due to insufficient fees.

**Type:** `neutron.globalfee.EventInsufficientFee`

**Attributes:**
- `tx_hash` (string): Transaction hash
- `required_fees` (Coins): Minimum required fees
- `provided_fees` (Coins): Fees provided by user
- `gas_used` (uint64): Total gas consumed

**Example:**
```json
{
  "type": "neutron.globalfee.EventInsufficientFee",
  "attributes": [
    {
      "key": "tx_hash",
      "value": "F6E5D4C3B2A1987..."
    },
    {
      "key": "required_fees",
      "value": "[{\"denom\":\"untrn\",\"amount\":\"5000\"}]"
    },
    {
      "key": "provided_fees",
      "value": "[{\"denom\":\"untrn\",\"amount\":\"1000\"}]"
    },
    {
      "key": "gas_used",
      "value": "200000"
    }
  ]
}
```

## Event Monitoring

### CLI Monitoring

**Monitor Parameter Updates:**
```bash
# Subscribe to parameter change events
neutrond query txs --events 'neutron.globalfee.EventUpdateParams.authority=neutron10d07y265gmmuvt4z0w9aw880jnsr700juxf95n'
```

**Monitor Fee Bypasses:**
```bash
# Monitor transactions that bypass fees
neutrond query txs --events 'neutron.globalfee.EventFeeBypass.bypass_reason=governance_message'
```

**Monitor Fee Rejections:**
```bash
# Monitor transactions rejected for insufficient fees
neutrond query txs --events 'neutron.globalfee.EventInsufficientFee'
```

### Programmatic Monitoring

#### Go Event Listener

```go
package main

import (
    "context"
    "fmt"
    "log"
    
    "github.com/cosmos/cosmos-sdk/types"
    "github.com/tendermint/tendermint/rpc/client/http"
)

func monitorGlobalFeeEvents() {
    client, err := http.New("tcp://localhost:26657", "/websocket")
    if err != nil {
        log.Fatal(err)
    }
    
    err = client.Start()
    if err != nil {
        log.Fatal(err)
    }
    defer client.Stop()
    
    // Subscribe to Global Fee events
    query := "neutron.globalfee.EventUpdateParams.authority EXISTS"
    ch, err := client.Subscribe(context.Background(), "globalfee-monitor", query)
    if err != nil {
        log.Fatal(err)
    }
    
    for event := range ch {
        fmt.Printf("Parameter update event: %+v\n", event.Data)
    }
}
```

#### JavaScript Event Listener

```javascript
import { Tendermint34Client } from "@cosmjs/tendermint-rpc";

async function monitorGlobalFeeEvents() {
  const client = await Tendermint34Client.connect("ws://localhost:26657/websocket");
  
  const stream = client.subscribeTx({
    "neutron.globalfee.EventFeeBypass.bypass_reason": "governance_message"
  });
  
  for await (const event of stream) {
    console.log("Fee bypass event:", event);
    
    // Process bypass event
    const attributes = event.events.find(e => e.type === "neutron.globalfee.EventFeeBypass");
    if (attributes) {
      const txHash = attributes.attributes.find(a => a.key === "tx_hash")?.value;
      const gasUsed = attributes.attributes.find(a => a.key === "gas_used")?.value;
      
      console.log(`Transaction ${txHash} bypassed fees using ${gasUsed} gas`);
    }
  }
}
```

### Event Analysis

#### Fee Bypass Analytics

```python
import json
from collections import defaultdict

def analyze_fee_bypass_events(events):
    """Analyze fee bypass patterns."""
    bypass_stats = defaultdict(int)
    total_gas_bypassed = 0
    
    for event in events:
        if event["type"] == "neutron.globalfee.EventFeeBypass":
            attrs = {attr["key"]: attr["value"] for attr in event["attributes"]}
            
            # Count bypasses by message type
            message_types = json.loads(attrs["message_types"])
            for msg_type in message_types:
                bypass_stats[msg_type] += 1
            
            # Track total gas bypassed
            total_gas_bypassed += int(attrs["gas_used"])
    
    return {
        "bypass_by_message_type": dict(bypass_stats),
        "total_gas_bypassed": total_gas_bypassed,
        "total_bypasses": len(events)
    }

# Usage
events = fetch_events_from_chain("neutron.globalfee.EventFeeBypass")
stats = analyze_fee_bypass_events(events)
print(f"Governance votes bypassed: {stats['bypass_by_message_type']['/cosmos.gov.v1beta1.MsgVote']}")
```

#### Fee Revenue Tracking

```go
func TrackFeeRevenue(events []types.Event) map[string]int64 {
    revenue := make(map[string]int64)
    
    for _, event := range events {
        if event.Type == "neutron.globalfee.EventInsufficientFee" {
            for _, attr := range event.Attributes {
                if string(attr.Key) == "required_fees" {
                    var coins []types.Coin
                    json.Unmarshal(attr.Value, &coins)
                    
                    for _, coin := range coins {
                        revenue[coin.Denom] += coin.Amount.Int64()
                    }
                }
            }
        }
    }
    
    return revenue
}
```

## Event Schema

### EventUpdateParams Schema

```protobuf
message EventUpdateParams {
  string authority = 1;
  Params params = 2 [(gogoproto.nullable) = false];
}
```

### EventFeeBypass Schema

```protobuf
message EventFeeBypass {
  string tx_hash = 1;
  uint64 gas_used = 2;
  repeated string message_types = 3;
  string bypass_reason = 4;
}
```

### EventInsufficientFee Schema

```protobuf
message EventInsufficientFee {
  string tx_hash = 1;
  repeated cosmos.base.v1beta1.Coin required_fees = 2 [(gogoproto.nullable) = false];
  repeated cosmos.base.v1beta1.Coin provided_fees = 3 [(gogoproto.nullable) = false];
  uint64 gas_used = 4;
}
```

## Best Practices

### Event Monitoring

1. **Real-time Alerts**: Set up alerts for unusual fee bypass patterns
2. **Revenue Tracking**: Monitor fee collection for economic analysis
3. **Parameter Changes**: Track governance parameter updates
4. **Performance Metrics**: Analyze gas usage patterns

### Event Processing

1. **Batch Processing**: Process events in batches for efficiency
2. **Error Handling**: Implement robust error handling for event parsing
3. **Data Persistence**: Store important events for historical analysis
4. **Rate Limiting**: Implement rate limiting for event subscriptions

### Security Monitoring

1. **Abuse Detection**: Monitor excessive fee bypass usage
2. **Parameter Validation**: Verify parameter changes are legitimate
3. **Gas Limit Monitoring**: Track bypass gas usage against limits
4. **Anomaly Detection**: Identify unusual fee patterns 