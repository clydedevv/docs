---
sidebar_position: 9
---

# Client

The Global Fee module provides query capabilities through CLI commands and gRPC/REST endpoints. Since parameters can only be updated through governance, there are no direct transaction commands.

## CLI Commands

### Query Commands

#### neutrond query globalfee params

Query the current Global Fee module parameters.

**Usage:**
```bash
neutrond query globalfee params [flags]
```

**Flags:**
- `--height int`: Use a specific height to query state at (this can error if the node is pruning state)
- `--node string`: \<host\>:\<port\> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
- `--output string`: Output format (text|json) (default "text")

**Examples:**

**Basic query:**
```bash
neutrond query globalfee params
```

**Output (text format):**
```yaml
bypass_min_fee_msg_types:
- /cosmos.gov.v1beta1.MsgVote  
- /cosmos.gov.v1beta1.MsgVoteWeighted
max_total_bypass_min_fee_msg_gas_usage: "1000000"
minimum_gas_prices:
- amount: "0.025000000000000000"
  denom: untrn
```

**JSON output:**
```bash
neutrond query globalfee params --output json
```

**Output (JSON format):**
```json
{
  "params": {
    "minimum_gas_prices": [
      {
        "denom": "untrn",
        "amount": "0.025000000000000000"
      }
    ],
    "bypass_min_fee_msg_types": [
      "/cosmos.gov.v1beta1.MsgVote",
      "/cosmos.gov.v1beta1.MsgVoteWeighted"
    ],
    "max_total_bypass_min_fee_msg_gas_usage": "1000000"
  }
}
```

**Query at specific height:**
```bash
neutrond query globalfee params --height 1000000
```

**Query from remote node:**
```bash
neutrond query globalfee params --node https://rpc.neutron.org:443
```

### Transaction Commands

The Global Fee module has no direct transaction commands. Parameter updates must be submitted through governance proposals.

**Submit parameter change proposal:**
```bash
neutrond tx gov submit-proposal param-change proposal.json \
  --from validator \
  --chain-id neutron-1 \
  --gas auto \
  --gas-adjustment 1.5 \
  --fees 1000untrn
```

## gRPC Client

### Go Client Implementation

```go
package main

import (
    "context"
    "fmt"
    "log"
    
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
    
    "github.com/neutron-org/neutron/v6/x/globalfee/types"
)

type GlobalFeeClient struct {
    conn   *grpc.ClientConn
    client types.QueryClient
}

func NewGlobalFeeClient(endpoint string) (*GlobalFeeClient, error) {
    conn, err := grpc.Dial(endpoint, grpc.WithTransportCredentials(insecure.NewCredentials()))
    if err != nil {
        return nil, err
    }
    
    client := types.NewQueryClient(conn)
    
    return &GlobalFeeClient{
        conn:   conn,
        client: client,
    }, nil
}

func (c *GlobalFeeClient) Close() error {
    return c.conn.Close()
}

func (c *GlobalFeeClient) GetParams(ctx context.Context) (*types.QueryParamsResponse, error) {
    req := &types.QueryParamsRequest{}
    return c.client.Params(ctx, req)
}

func (c *GlobalFeeClient) GetMinimumGasPrices(ctx context.Context) ([]types.DecCoin, error) {
    resp, err := c.GetParams(ctx)
    if err != nil {
        return nil, err
    }
    
    return resp.Params.MinimumGasPrices, nil
}

func (c *GlobalFeeClient) GetBypassMessageTypes(ctx context.Context) ([]string, error) {
    resp, err := c.GetParams(ctx)
    if err != nil {
        return nil, err
    }
    
    return resp.Params.BypassMinFeeMsgTypes, nil
}

func (c *GlobalFeeClient) CalculateMinimumFee(ctx context.Context, gasUsed uint64, denom string) (int64, error) {
    gasPrices, err := c.GetMinimumGasPrices(ctx)
    if err != nil {
        return 0, err
    }
    
    for _, gasPrice := range gasPrices {
        if gasPrice.Denom == denom {
            fee := gasPrice.Amount.MulInt64(int64(gasUsed)).Ceil().TruncateInt()
            return fee.Int64(), nil
        }
    }
    
    return 0, fmt.Errorf("no gas price found for denom %s", denom)
}

// Usage example
func main() {
    client, err := NewGlobalFeeClient("localhost:9090")
    if err != nil {
        log.Fatal(err)
    }
    defer client.Close()
    
    ctx := context.Background()
    
    // Get parameters
    params, err := client.GetParams(ctx)
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("Global Fee Parameters:\n")
    fmt.Printf("Minimum Gas Prices: %v\n", params.Params.MinimumGasPrices)
    fmt.Printf("Bypass Message Types: %v\n", params.Params.BypassMinFeeMsgTypes)
    fmt.Printf("Max Bypass Gas Usage: %d\n", params.Params.MaxTotalBypassMinFeeMsgGasUsage)
    
    // Calculate minimum fee
    fee, err := client.CalculateMinimumFee(ctx, 200000, "untrn")
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("Minimum fee for 200k gas: %d untrn\n", fee)
}
```

### JavaScript/TypeScript Client

```typescript
import { QueryClient } from "@cosmjs/stargate";
import { Tendermint34Client } from "@cosmjs/tendermint-rpc";
import Long from "long";

interface DecCoin {
  denom: string;
  amount: string;
}

interface GlobalFeeParams {
  minimum_gas_prices: DecCoin[];
  bypass_min_fee_msg_types: string[];
  max_total_bypass_min_fee_msg_gas_usage: Long;
}

export class GlobalFeeQueryClient {
  private queryClient: QueryClient;

  constructor(queryClient: QueryClient) {
    this.queryClient = queryClient;
  }

  static async connect(rpcEndpoint: string): Promise<GlobalFeeQueryClient> {
    const tmClient = await Tendermint34Client.connect(rpcEndpoint);
    const queryClient = new QueryClient(tmClient);
    return new GlobalFeeQueryClient(queryClient);
  }

  async getParams(): Promise<GlobalFeeParams> {
    const response = await this.queryClient.queryAbci("/neutron.globalfee.Query/Params", new Uint8Array());
    
    // Decode protobuf response (implementation depends on your protobuf library)
    const decoded = this.decodeParamsResponse(response.value);
    return decoded.params;
  }

  async getMinimumGasPrices(): Promise<DecCoin[]> {
    const params = await this.getParams();
    return params.minimum_gas_prices;
  }

  async getBypassMessageTypes(): Promise<string[]> {
    const params = await this.getParams();
    return params.bypass_min_fee_msg_types;
  }

  async calculateMinimumFee(gasUsed: number, denom: string): Promise<number> {
    const gasPrices = await this.getMinimumGasPrices();
    
    const gasPrice = gasPrices.find(price => price.denom === denom);
    if (!gasPrice) {
      throw new Error(`No gas price found for denom ${denom}`);
    }
    
    const fee = Math.ceil(gasUsed * parseFloat(gasPrice.amount));
    return fee;
  }

  async isMessageTypeBypassEligible(messageType: string): Promise<boolean> {
    const bypassTypes = await this.getBypassMessageTypes();
    return bypassTypes.includes(messageType);
  }

  private decodeParamsResponse(data: Uint8Array): { params: GlobalFeeParams } {
    // Implementation depends on your protobuf decoding library
    // This is a placeholder - use appropriate protobuf decoder
    throw new Error("Implement protobuf decoding");
  }

  disconnect(): void {
    this.queryClient.disconnect();
  }
}

// Usage example
async function example() {
  const client = await GlobalFeeQueryClient.connect("https://rpc.neutron.org");
  
  try {
    // Get parameters
    const params = await client.getParams();
    console.log("Global Fee Parameters:", params);
    
    // Calculate minimum fee
    const fee = await client.calculateMinimumFee(200000, "untrn");
    console.log(`Minimum fee for 200k gas: ${fee} untrn`);
    
    // Check if message type is bypass eligible
    const isEligible = await client.isMessageTypeBypassEligible("/cosmos.gov.v1beta1.MsgVote");
    console.log(`Governance vote bypass eligible: ${isEligible}`);
    
  } finally {
    client.disconnect();
  }
}
```

## REST Client

### Python Client

```python
import requests
from typing import List, Dict, Any, Optional
from dataclasses import dataclass

@dataclass
class DecCoin:
    denom: str
    amount: str

@dataclass
class GlobalFeeParams:
    minimum_gas_prices: List[DecCoin]
    bypass_min_fee_msg_types: List[str]
    max_total_bypass_min_fee_msg_gas_usage: int

class GlobalFeeRestClient:
    def __init__(self, rest_endpoint: str = "https://rest.neutron.org"):
        self.rest_endpoint = rest_endpoint.rstrip("/")
    
    def get_params(self) -> GlobalFeeParams:
        """Get Global Fee module parameters."""
        url = f"{self.rest_endpoint}/neutron/globalfee/v1beta1/params"
        
        response = requests.get(url)
        response.raise_for_status()
        
        data = response.json()["params"]
        
        return GlobalFeeParams(
            minimum_gas_prices=[
                DecCoin(denom=coin["denom"], amount=coin["amount"])
                for coin in data["minimum_gas_prices"]
            ],
            bypass_min_fee_msg_types=data["bypass_min_fee_msg_types"],
            max_total_bypass_min_fee_msg_gas_usage=int(data["max_total_bypass_min_fee_msg_gas_usage"])
        )
    
    def get_minimum_gas_prices(self) -> List[DecCoin]:
        """Get minimum gas prices."""
        params = self.get_params()
        return params.minimum_gas_prices
    
    def get_bypass_message_types(self) -> List[str]:
        """Get bypass message types."""
        params = self.get_params()
        return params.bypass_min_fee_msg_types
    
    def calculate_minimum_fee(self, gas_used: int, denom: str) -> int:
        """Calculate minimum fee for given gas usage and denomination."""
        gas_prices = self.get_minimum_gas_prices()
        
        for price in gas_prices:
            if price.denom == denom:
                gas_price = float(price.amount)
                return int(gas_used * gas_price)
        
        raise ValueError(f"No gas price found for denom {denom}")
    
    def is_message_type_bypass_eligible(self, message_type: str) -> bool:
        """Check if message type is eligible for fee bypass."""
        bypass_types = self.get_bypass_message_types()
        return message_type in bypass_types
    
    def get_required_fees_for_transaction(self, gas_used: int) -> List[Dict[str, Any]]:
        """Get required fees for a transaction with given gas usage."""
        gas_prices = self.get_minimum_gas_prices()
        
        required_fees = []
        for price in gas_prices:
            fee_amount = int(gas_used * float(price.amount))
            if fee_amount > 0:
                required_fees.append({
                    "denom": price.denom,
                    "amount": str(fee_amount)
                })
        
        return required_fees

# Usage example
if __name__ == "__main__":
    client = GlobalFeeRestClient()
    
    # Get parameters
    params = client.get_params()
    print(f"Minimum gas prices: {params.minimum_gas_prices}")
    print(f"Bypass message types: {params.bypass_min_fee_msg_types}")
    print(f"Max bypass gas usage: {params.max_total_bypass_min_fee_msg_gas_usage}")
    
    # Calculate fees
    try:
        fee = client.calculate_minimum_fee(200000, "untrn")
        print(f"Minimum fee for 200k gas: {fee} untrn")
    except ValueError as e:
        print(f"Error: {e}")
    
    # Check bypass eligibility
    is_eligible = client.is_message_type_bypass_eligible("/cosmos.gov.v1beta1.MsgVote")
    print(f"Governance vote bypass eligible: {is_eligible}")
    
    # Get required fees
    required_fees = client.get_required_fees_for_transaction(150000)
    print(f"Required fees for 150k gas: {required_fees}")
```

### cURL Examples

**Get Parameters:**
```bash
curl -X GET "https://rest.neutron.org/neutron/globalfee/v1beta1/params" \
  -H "accept: application/json" | jq
```

**Extract Minimum Gas Prices:**
```bash
curl -s "https://rest.neutron.org/neutron/globalfee/v1beta1/params" | \
  jq '.params.minimum_gas_prices'
```

**Extract Bypass Message Types:**
```bash
curl -s "https://rest.neutron.org/neutron/globalfee/v1beta1/params" | \
  jq '.params.bypass_min_fee_msg_types'
```

**Calculate Fee (using jq):**
```bash
# Calculate minimum fee for 200,000 gas in untrn
GAS_USED=200000
DENOM="untrn"

FEE=$(curl -s "https://rest.neutron.org/neutron/globalfee/v1beta1/params" | \
  jq -r --arg denom "$DENOM" --argjson gas "$GAS_USED" \
  '.params.minimum_gas_prices[] | select(.denom == $denom) | (.amount | tonumber) * $gas | floor')

echo "Minimum fee: ${FEE}${DENOM}"
```

## Client Utilities

### Fee Calculator Utility

```go
package utils

import (
    "fmt"
    "math"
    
    sdk "github.com/cosmos/cosmos-sdk/types"
    "github.com/neutron-org/neutron/v6/x/globalfee/types"
)

type FeeCalculator struct {
    params types.Params
}

func NewFeeCalculator(params types.Params) *FeeCalculator {
    return &FeeCalculator{params: params}
}

func (fc *FeeCalculator) CalculateMinimumFees(gasUsed uint64) sdk.Coins {
    var fees sdk.Coins
    
    for _, gasPrice := range fc.params.MinimumGasPrices {
        feeAmount := gasPrice.Amount.MulInt64(int64(gasUsed)).Ceil().TruncateInt()
        if feeAmount.IsPositive() {
            fees = fees.Add(sdk.NewCoin(gasPrice.Denom, feeAmount))
        }
    }
    
    return fees
}

func (fc *FeeCalculator) IsTransactionBypassEligible(msgs []sdk.Msg, gasUsed uint64) bool {
    // Check if all messages are bypass eligible
    for _, msg := range msgs {
        msgType := sdk.MsgTypeURL(msg)
        if !fc.isMessageTypeBypassEligible(msgType) {
            return false
        }
    }
    
    // Check gas usage limit
    return gasUsed <= fc.params.MaxTotalBypassMinFeeMsgGasUsage
}

func (fc *FeeCalculator) isMessageTypeBypassEligible(msgType string) bool {
    for _, bypassType := range fc.params.BypassMinFeeMsgTypes {
        if msgType == bypassType {
            return true
        }
    }
    return false
}

func (fc *FeeCalculator) ValidateTransactionFees(fees sdk.Coins, gasUsed uint64) error {
    requiredFees := fc.CalculateMinimumFees(gasUsed)
    
    // Check if any required fee denomination is satisfied
    for _, requiredFee := range requiredFees {
        paidAmount := fees.AmountOf(requiredFee.Denom)
        if paidAmount.GTE(requiredFee.Amount) {
            return nil // At least one denomination meets requirement
        }
    }
    
    return fmt.Errorf("insufficient fee: got %s, required %s", fees, requiredFees)
}
```

### Transaction Builder Helper

```typescript
interface TransactionFeeInfo {
  fees: Array<{ denom: string; amount: string }>;
  gasUsed: number;
  bypassEligible: boolean;
  requiredFees: Array<{ denom: string; amount: string }>;
}

export class GlobalFeeTransactionHelper {
  private client: GlobalFeeQueryClient;

  constructor(client: GlobalFeeQueryClient) {
    this.client = client;
  }

  async calculateTransactionFees(
    messageTypes: string[],
    estimatedGas: number
  ): Promise<TransactionFeeInfo> {
    const params = await this.client.getParams();
    
    // Check bypass eligibility
    const allBypassEligible = messageTypes.every(msgType =>
      params.bypass_min_fee_msg_types.includes(msgType)
    );
    
    const bypassEligible = allBypassEligible && 
      estimatedGas <= params.max_total_bypass_min_fee_msg_gas_usage.toNumber();
    
    // Calculate required fees
    const requiredFees = params.minimum_gas_prices.map(gasPrice => ({
      denom: gasPrice.denom,
      amount: Math.ceil(estimatedGas * parseFloat(gasPrice.amount)).toString()
    }));
    
    return {
      fees: bypassEligible ? [] : requiredFees,
      gasUsed: estimatedGas,
      bypassEligible,
      requiredFees
    };
  }

  async buildOptimalFeeArray(estimatedGas: number): Promise<Array<{ denom: string; amount: string }>> {
    const gasPrices = await this.client.getMinimumGasPrices();
    
    // Choose the cheapest denomination (if multiple available)
    if (gasPrices.length === 0) {
      return [];
    }
    
    // For simplicity, use the first denomination
    // In practice, you might want to choose based on user preference or market rates
    const chosenPrice = gasPrices[0];
    const feeAmount = Math.ceil(estimatedGas * parseFloat(chosenPrice.amount));
    
    return [{
      denom: chosenPrice.denom,
      amount: feeAmount.toString()
    }];
  }
}
``` 