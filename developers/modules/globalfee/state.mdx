---
sidebar_position: 8
---

# State

The Global Fee module maintains minimal state, storing only its parameters in the module's key-value store.

## State Objects

### Parameters

The Global Fee module stores its parameters as a single state object.

**Key:** `ParamsKey = []byte{0x01}`  
**Value:** Protobuf-encoded `Params` structure  
**Store:** Module-specific KV store with prefix `GlobalFeeStoreKey`

#### Params Structure

```protobuf
message Params {
  repeated cosmos.base.v1beta1.DecCoin minimum_gas_prices = 1 [
    (gogoproto.nullable) = false,
    (gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.DecCoins"
  ];
  repeated string bypass_min_fee_msg_types = 2;
  uint64 max_total_bypass_min_fee_msg_gas_usage = 3;
}
```

## State Transitions

### Parameter Updates

Parameters can only be updated through governance proposals using `MsgUpdateParams`.

**State Transition:**
```
Old State: Params{minimum_gas_prices: [old_prices], ...}
Trigger:   MsgUpdateParams via governance
New State: Params{minimum_gas_prices: [new_prices], ...}
```

**Validation Rules:**
- `minimum_gas_prices` must be sorted by denomination
- No duplicate denominations allowed
- No zero or negative amounts
- `bypass_min_fee_msg_types` must be valid message type URLs
- `max_total_bypass_min_fee_msg_gas_usage` must be positive

### State Access Patterns

#### Read Operations

**Get Parameters:**
```go
func (k Keeper) GetParams(ctx sdk.Context) types.Params {
    store := ctx.KVStore(k.storeKey)
    bz := store.Get(types.ParamsKey)
    if bz == nil {
        return types.Params{} // Return default params
    }
    
    var params types.Params
    k.cdc.MustUnmarshal(bz, &params)
    return params
}
```

#### Write Operations

**Set Parameters:**
```go
func (k Keeper) SetParams(ctx sdk.Context, params types.Params) error {
    if err := params.ValidateBasic(); err != nil {
        return err
    }
    
    store := ctx.KVStore(k.storeKey)
    bz := k.cdc.MustMarshal(&params)
    store.Set(types.ParamsKey, bz)
    
    return nil
}
```

## State Storage

### Key-Value Store Layout

```
GlobalFeeStore/
├── 0x01 → Params (protobuf-encoded)
```

### Storage Details

#### Store Key
- **Module Store Key:** `"globalfee"`
- **KV Store:** Cosmos SDK KVStore with module prefix
- **Persistence:** State is persisted across blocks and node restarts

#### Encoding
- **Format:** Protocol Buffers (protobuf)
- **Codec:** Cosmos SDK binary codec
- **Compression:** Standard protobuf compression

### Memory Usage

The Global Fee module has minimal memory footprint:
- **Parameters:** ~1KB typical size
- **Cache:** Parameters cached in memory during block execution
- **Garbage Collection:** No cleanup required (single state object)

## State Migration

### Genesis State

**Genesis Structure:**
```protobuf
message GenesisState {
  Params params = 1 [(gogoproto.nullable) = false];
}
```

**Default Genesis:**
```json
{
  "params": {
    "minimum_gas_prices": [],
    "bypass_min_fee_msg_types": [
      "/cosmos.gov.v1beta1.MsgVote",
      "/cosmos.gov.v1beta1.MsgVoteWeighted"
    ],
    "max_total_bypass_min_fee_msg_gas_usage": "1000000"
  }
}
```

### State Export/Import

**Export State:**
```go
func (k Keeper) ExportGenesis(ctx sdk.Context) *types.GenesisState {
    params := k.GetParams(ctx)
    return &types.GenesisState{
        Params: params,
    }
}
```

**Import State:**
```go
func (k Keeper) InitGenesis(ctx sdk.Context, genState types.GenesisState) {
    k.SetParams(ctx, genState.Params)
}
```

### Upgrade Handling

**Version Migration:**
```go
func (m Migrator) Migrate1to2(ctx sdk.Context) error {
    // Example migration from v1 to v2
    params := m.keeper.GetParams(ctx)
    
    // Add new default bypass message types
    params.BypassMinFeeMsgTypes = append(params.BypassMinFeeMsgTypes,
        "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward")
    
    return m.keeper.SetParams(ctx, params)
}
```

## State Queries

### Direct State Access

**Get Raw Parameters:**
```bash
# Query raw state
neutrond query store globalfee key 01 --node tcp://localhost:26657
```

**Decode Parameters:**
```bash
# Get decoded parameters
neutrond query globalfee params --node tcp://localhost:26657
```

### Programmatic Access

#### Go Client

```go
import (
    "github.com/neutron-org/neutron/v6/x/globalfee/types"
    "github.com/cosmos/cosmos-sdk/client"
)

func queryGlobalFeeState(clientCtx client.Context) error {
    queryClient := types.NewQueryClient(clientCtx)
    
    resp, err := queryClient.Params(context.Background(), &types.QueryParamsRequest{})
    if err != nil {
        return err
    }
    
    fmt.Printf("State: %+v\n", resp.Params)
    return nil
}
```

#### JavaScript Client

```javascript
async function queryGlobalFeeState(client) {
  const response = await client.queryAbci("/neutron.globalfee.Query/Params", new Uint8Array());
  const decoded = /* decode protobuf response */;
  
  return decoded.params;
}
```

## State Validation

### Parameter Validation

**Validation Rules:**
```go
func (p Params) ValidateBasic() error {
    // Validate minimum gas prices
    if err := p.MinimumGasPrices.Validate(); err != nil {
        return err
    }
    
    // Check for sorted denominations
    if !p.MinimumGasPrices.IsValid() {
        return errors.New("minimum gas prices must be sorted")
    }
    
    // Validate bypass message types
    for _, msgType := range p.BypassMinFeeMsgTypes {
        if !strings.HasPrefix(msgType, "/") {
            return fmt.Errorf("invalid message type: %s", msgType)
        }
    }
    
    // Validate gas usage limit
    if p.MaxTotalBypassMinFeeMsgGasUsage == 0 {
        return errors.New("max bypass gas usage must be positive")
    }
    
    return nil
}
```

### State Consistency

**Invariants:**
1. Parameters must always pass validation
2. Minimum gas prices must be sorted by denomination
3. No duplicate denominations in gas prices
4. Bypass message types must be valid URLs
5. Gas usage limit must be positive

**Invariant Checks:**
```go
func GlobalFeeInvariant(k Keeper) sdk.Invariant {
    return func(ctx sdk.Context) (string, bool) {
        params := k.GetParams(ctx)
        
        if err := params.ValidateBasic(); err != nil {
            return fmt.Sprintf("global fee parameters invalid: %v", err), true
        }
        
        return "global fee parameters are valid", false
    }
}
```

## Performance Considerations

### State Access Performance

1. **Parameter Caching:** Parameters are cached during block execution
2. **Read Optimization:** Single key-value lookup for all parameters
3. **Write Frequency:** Parameters change infrequently (governance only)
4. **Memory Efficiency:** Minimal state footprint

### Optimization Strategies

1. **Batch Reads:** Read parameters once per block
2. **Context Caching:** Cache parameters in block context
3. **Lazy Loading:** Load parameters only when needed
4. **Validation Caching:** Cache validation results

## State Monitoring

### Health Checks

```bash
# Verify state consistency
neutrond query globalfee params --output json | jq '.params | keys'

# Check parameter values
neutrond query globalfee params --output json | jq '.params.minimum_gas_prices'
```

### Metrics Collection

```go
func CollectGlobalFeeMetrics(k Keeper, ctx sdk.Context) {
    params := k.GetParams(ctx)
    
    // Metric: Number of minimum gas price denominations
    gasPriceDenoms.Set(float64(len(params.MinimumGasPrices)))
    
    // Metric: Number of bypass message types
    bypassMsgTypes.Set(float64(len(params.BypassMinFeeMsgTypes)))
    
    // Metric: Maximum bypass gas usage
    maxBypassGas.Set(float64(params.MaxTotalBypassMinFeeMsgGasUsage))
}
``` 