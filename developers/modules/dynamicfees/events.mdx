---
title: "Dynamic Fees Events"
description: "Events emitted by the Dynamic Fees module"
---

# Events

The Dynamic Fees module emits events during parameter updates and conversion operations.

## Parameter Update Events

### MsgUpdateParams

When module parameters are updated through governance, the following events are emitted:

#### Message Event

**Type:** `message`

**Emitted when:** A governance proposal successfully updates module parameters

**Attributes:**

| Key | Value | Description |
|-----|-------|-------------|
| `action` | `/neutron.dynamicfees.MsgUpdateParams` | The message type that triggered the event |
| `module` | `dynamicfees` | The module that emitted the event |
| `sender` | `{governance_authority}` | The governance authority address |

**Example:**
```json
{
  "type": "message",
  "attributes": [
    {
      "key": "action",
      "value": "/neutron.dynamicfees.MsgUpdateParams"
    },
    {
      "key": "module",
      "value": "dynamicfees"
    },
    {
      "key": "sender", 
      "value": "neutron10d07y265gmmuvt4z0w9aw880jnsr700j6zn9kn"
    }
  ]
}
```

## Event Monitoring

### Listening for Parameter Changes

Applications can monitor for Dynamic Fees parameter updates:

#### Using WebSocket

```typescript
import { WebSocketClient } from "@cosmjs/tendermint-rpc";

async function monitorParameterChanges() {
  const client = new WebSocketClient("ws://localhost:26657/websocket");
  
  const query = "tm.event='Tx' AND message.action='/neutron.dynamicfees.MsgUpdateParams'";
  
  const stream = client.subscribe({
    query: query
  });
  
  stream.addListener({
    next: (event) => {
      console.log("Dynamic Fees parameters updated:", event);
      // Handle parameter change
      handleParameterUpdate(event);
    },
    error: (error) => {
      console.error("WebSocket error:", error);
    },
    complete: () => {
      console.log("WebSocket connection closed");
    }
  });
}

function handleParameterUpdate(event: any) {
  // Extract new parameters from the event
  // Refresh local price cache
  // Notify dependent systems
}
```

#### Using Event Polling

```typescript
async function pollForParameterChanges() {
  let lastHeight = await getCurrentBlockHeight();
  
  setInterval(async () => {
    const currentHeight = await getCurrentBlockHeight();
    
    if (currentHeight > lastHeight) {
      const events = await queryEventsByHeight(lastHeight + 1, currentHeight);
      
      const parameterUpdates = events.filter(event => 
        event.type === "message" && 
        event.attributes.some(attr => 
          attr.key === "action" && 
          attr.value === "/neutron.dynamicfees.MsgUpdateParams"
        )
      );
      
      if (parameterUpdates.length > 0) {
        console.log("Parameter updates detected:", parameterUpdates);
        await refreshParameterCache();
      }
      
      lastHeight = currentHeight;
    }
  }, 5000); // Poll every 5 seconds
}
```

### Event Filtering

#### CLI Event Queries

```bash
# Query for parameter update events
neutrond query txs --events "message.action='/neutron.dynamicfees.MsgUpdateParams'"

# Query events from specific block range
neutrond query txs --events "message.action='/neutron.dynamicfees.MsgUpdateParams'" \
  --height 1000000

# Query with additional filters
neutrond query txs --events \
  "message.action='/neutron.dynamicfees.MsgUpdateParams' AND message.sender='neutron10d07y265gmmuvt4z0w9aw880jnsr700j6zn9kn'"
```

#### gRPC Event Queries

```go
import (
    "context"
    "github.com/cosmos/cosmos-sdk/client"
    "github.com/cosmos/cosmos-sdk/types/query"
    txtypes "github.com/cosmos/cosmos-sdk/types/tx"
)

func queryParameterUpdateEvents(ctx context.Context, clientCtx client.Context) error {
    txServiceClient := txtypes.NewServiceClient(clientCtx)
    
    // Query for parameter update transactions
    req := &txtypes.GetTxsEventRequest{
        Events: []string{"message.action='/neutron.dynamicfees.MsgUpdateParams'"},
        Pagination: &query.PageRequest{
            Limit: 10,
        },
    }
    
    resp, err := txServiceClient.GetTxsEvent(ctx, req)
    if err != nil {
        return err
    }
    
    for _, tx := range resp.Txs {
        // Process parameter update transaction
        processTx(tx)
    }
    
    return nil
}
```

## Integration Patterns

### Cache Invalidation

When parameter update events are detected, applications should invalidate cached price data:

```typescript
class DynamicFeesCache {
  private priceCache: Map<string, string> = new Map();
  private lastUpdate: number = 0;
  
  constructor() {
    this.monitorParameterChanges();
  }
  
  private async monitorParameterChanges() {
    // Set up event listener for parameter changes
    const client = await getWebSocketClient();
    
    client.subscribe({
      query: "tm.event='Tx' AND message.action='/neutron.dynamicfees.MsgUpdateParams'"
    }, (event) => {
      console.log('Parameter update detected, invalidating cache');
      this.invalidateCache();
    });
  }
  
  private invalidateCache() {
    this.priceCache.clear();
    this.lastUpdate = Date.now();
    
    // Notify subscribers of cache invalidation
    this.notifySubscribers();
  }
  
  async getPrice(denom: string): Promise<string | null> {
    if (!this.priceCache.has(denom)) {
      await this.refreshCache();
    }
    
    return this.priceCache.get(denom) || null;
  }
}
```

### Real-time Price Updates

```typescript
interface PriceUpdateListener {
  onPriceUpdate(denom: string, newPrice: string): void;
}

class DynamicFeesMonitor {
  private listeners: PriceUpdateListener[] = [];
  
  addListener(listener: PriceUpdateListener) {
    this.listeners.push(listener);
  }
  
  private async handleParameterUpdate(event: any) {
    // Parse the new parameters from the event
    const newParams = await this.parseParametersFromEvent(event);
    
    // Compare with previous parameters and notify listeners
    for (const price of newParams.ntrn_prices) {
      this.listeners.forEach(listener => {
        listener.onPriceUpdate(price.denom, price.amount);
      });
    }
  }
}
```

## Event Structure Details

### Transaction Events

Parameter update transactions contain multiple events:

1. **Governance Events**: Related to proposal execution
2. **Module Events**: Specific to Dynamic Fees parameter updates
3. **Bank Events**: If any fee payments are involved

### Event Attributes

All event attributes are strings, even numeric values:

```json
{
  "type": "message",
  "attributes": [
    {
      "key": "action",
      "value": "/neutron.dynamicfees.MsgUpdateParams"
    },
    {
      "key": "module",
      "value": "dynamicfees"
    },
    {
      "key": "sender",
      "value": "neutron10d07y265gmmuvt4z0w9aw880jnsr700j6zn9kn"
    }
  ]
}
```

### Block vs Transaction Events

- **Block Events**: Emitted at the end of block processing
- **Transaction Events**: Emitted during transaction execution
- **Parameter Updates**: Appear as transaction events

## Debugging Events

### Event Inspection

```bash
# Get detailed transaction information
neutrond query tx {transaction_hash} --output json

# Filter for specific event types
neutrond query tx {transaction_hash} --output json | jq '.logs[].events[] | select(.type == "message")'

# Extract event attributes
neutrond query tx {transaction_hash} --output json | jq '.logs[].events[] | select(.type == "message") | .attributes'
```

### Common Event Patterns

```bash
# All Dynamic Fees related events
neutrond query txs --events "message.module='dynamicfees'"

# Parameter updates only
neutrond query txs --events "message.action='/neutron.dynamicfees.MsgUpdateParams'"

# Events from specific governance authority
neutrond query txs --events "message.sender='neutron10d07y265gmmuvt4z0w9aw880jnsr700j6zn9kn'"
```

The Dynamic Fees module has a simple event model focused on parameter updates, making it straightforward to monitor and integrate with external systems.