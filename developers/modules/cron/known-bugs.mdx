---
title: "Known Bugs"
description: "Current known issues and limitations of the Cron module"
---

### Schedule execution limits per block

The Cron module has a built-in limitation on how many schedules can be executed in a single block. When there are many schedules due for execution at the same block height, only a limited number will be processed in that block, with the remaining schedules deferred to subsequent blocks.

This is by design to prevent block congestion, but it means that during periods with many concurrent schedules, some executions may be delayed by one or more blocks:

```rust
// In your contract, you can add checks for execution timing if needed
let current_height = env.block.height;
let expected_height = last_execution + period;
let delay_blocks = current_height.saturating_sub(expected_height);

if delay_blocks > 0 {
    // Log the delay for monitoring
    deps.api.debug(&format!(
        "Schedule execution delayed by {} blocks", 
        delay_blocks
    ));
}
```

### Block-based execution timing

The Cron module operates on block heights, not precise timestamps. This means:

- Execution timing depends on block production rate
- Network upgrades or changes in validator behavior can affect timing
- There is no "precise timing" by design - schedules execute at block intervals

Applications should be designed with this block-based execution in mind:

```rust
// Design your scheduled tasks to be tolerant of block-based timing
fn handle_scheduled_execution(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
) -> StdResult<Response> {
    // Don't rely on precise timing - design for block-based execution
    let current_block = env.block.height;
    
    // Perform the scheduled task
    execute_periodic_task(deps, current_block)?;
    
    Ok(Response::new()
        .add_attribute("action", "scheduled_execution")
        .add_attribute("block", current_block.to_string()))
}
```

### Schedule name uniqueness

Schedule names must be unique across the entire network. If a schedule with the same name already exists, attempts to create a new schedule with that name will fail.

To avoid conflicts:

```rust
// Use descriptive, unique names that include context
let schedule_name = format!("protocol_v2_daily_maintenance_{}", unique_id);

// Or include contract address for uniqueness
let schedule_name = format!("{}_reward_distribution", env.contract.address);
```

### Governance-only schedule management

All schedule operations (create, update, remove) are governance-gated. This means:

- Individual users cannot create schedules directly
- All schedule changes require governance proposals
- Emergency schedule removal requires governance action

Plan accordingly for:
- Lead time needed for governance proposals
- Community consensus building
- Emergency procedures through governance

This design prevents spam and ensures only approved schedules run on the network, but requires advance planning for schedule management. 