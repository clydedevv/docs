---
sidebar_position: 8
---

# Events

The Token Factory module emits events for all token creation and management operations.

## Token Creation Events

### EventCreateDenom

Emitted when a new token denomination is created.

**Type:** `neutron.tokenfactory.EventCreateDenom`

**Attributes:**
- `creator` (string): Address that created the token
- `denom` (string): Full denomination created
- `subdenom` (string): Subdenom chosen by creator

**Example:**
```json
{
  "type": "neutron.tokenfactory.EventCreateDenom",
  "attributes": [
    {
      "key": "creator",
      "value": "neutron1abc123..."
    },
    {
      "key": "denom",
      "value": "factory/neutron1abc123.../mytoken"
    },
    {
      "key": "subdenom",
      "value": "mytoken"
    }
  ]
}
```

## Token Supply Events

### EventMint

Emitted when tokens are minted.

**Type:** `neutron.tokenfactory.EventMint`

**Attributes:**
- `admin` (string): Admin address that performed the mint
- `denom` (string): Token denomination
- `amount` (string): Amount minted
- `recipient` (string): Address that received minted tokens

**Example:**
```json
{
  "type": "neutron.tokenfactory.EventMint",
  "attributes": [
    {
      "key": "admin",
      "value": "neutron1admin..."
    },
    {
      "key": "denom",
      "value": "factory/neutron1abc123.../mytoken"
    },
    {
      "key": "amount",
      "value": "1000000"
    },
    {
      "key": "recipient",
      "value": "neutron1recipient..."
    }
  ]
}
```

### EventBurn

Emitted when tokens are burned.

**Type:** `neutron.tokenfactory.EventBurn`

**Attributes:**
- `admin` (string): Admin address that performed the burn
- `denom` (string): Token denomination
- `amount` (string): Amount burned
- `burn_from` (string): Address tokens were burned from

**Example:**
```json
{
  "type": "neutron.tokenfactory.EventBurn",
  "attributes": [
    {
      "key": "admin",
      "value": "neutron1admin..."
    },
    {
      "key": "denom",
      "value": "factory/neutron1abc123.../mytoken"
    },
    {
      "key": "amount",
      "value": "500000"
    },
    {
      "key": "burn_from",
      "value": "neutron1holder..."
    }
  ]
}
```

## Admin Management Events

### EventChangeAdmin

Emitted when token admin is changed.

**Type:** `neutron.tokenfactory.EventChangeAdmin`

**Attributes:**
- `denom` (string): Token denomination
- `old_admin` (string): Previous admin address
- `new_admin` (string): New admin address (empty if renounced)

**Example:**
```json
{
  "type": "neutron.tokenfactory.EventChangeAdmin",
  "attributes": [
    {
      "key": "denom",
      "value": "factory/neutron1abc123.../mytoken"
    },
    {
      "key": "old_admin",
      "value": "neutron1oldadmin..."
    },
    {
      "key": "new_admin",
      "value": "neutron1newadmin..."
    }
  ]
}
```

**Admin Renouncement Example:**
```json
{
  "type": "neutron.tokenfactory.EventChangeAdmin",
  "attributes": [
    {
      "key": "denom",
      "value": "factory/neutron1abc123.../mytoken"
    },
    {
      "key": "old_admin",
      "value": "neutron1admin..."
    },
    {
      "key": "new_admin",
      "value": ""
    }
  ]
}
```

## Metadata Events

### EventSetDenomMetadata

Emitted when token metadata is set or updated.

**Type:** `neutron.tokenfactory.EventSetDenomMetadata`

**Attributes:**
- `admin` (string): Admin address that set metadata
- `denom` (string): Token denomination
- `metadata` (string): JSON-encoded metadata

**Example:**
```json
{
  "type": "neutron.tokenfactory.EventSetDenomMetadata",
  "attributes": [
    {
      "key": "admin",
      "value": "neutron1admin..."
    },
    {
      "key": "denom",
      "value": "factory/neutron1abc123.../mytoken"
    },
    {
      "key": "metadata",
      "value": "{\"name\":\"My Token\",\"symbol\":\"MT\",\"description\":\"Custom token\",\"decimals\":6}"
    }
  ]
}
```

## Hook Events

### EventSetBeforeSendHook

Emitted when a before-send hook is set or removed.

**Type:** `neutron.tokenfactory.EventSetBeforeSendHook`

**Attributes:**
- `admin` (string): Admin address that set the hook
- `denom` (string): Token denomination
- `contract_addr` (string): Hook contract address (empty if removed)

**Example (Setting Hook):**
```json
{
  "type": "neutron.tokenfactory.EventSetBeforeSendHook",
  "attributes": [
    {
      "key": "admin",
      "value": "neutron1admin..."
    },
    {
      "key": "denom",
      "value": "factory/neutron1abc123.../mytoken"
    },
    {
      "key": "contract_addr",
      "value": "neutron1hook_contract..."
    }
  ]
}
```

**Example (Removing Hook):**
```json
{
  "type": "neutron.tokenfactory.EventSetBeforeSendHook",
  "attributes": [
    {
      "key": "admin",
      "value": "neutron1admin..."
    },
    {
      "key": "denom",
      "value": "factory/neutron1abc123.../mytoken"
    },
    {
      "key": "contract_addr",
      "value": ""
    }
  ]
}
```

## Transfer Events

### EventForceTransfer

Emitted when admin performs a force transfer.

**Type:** `neutron.tokenfactory.EventForceTransfer`

**Attributes:**
- `admin` (string): Admin address that performed force transfer
- `denom` (string): Token denomination
- `amount` (string): Amount transferred
- `from` (string): Source address
- `to` (string): Destination address

**Example:**
```json
{
  "type": "neutron.tokenfactory.EventForceTransfer",
  "attributes": [
    {
      "key": "admin",
      "value": "neutron1admin..."
    },
    {
      "key": "denom",
      "value": "factory/neutron1abc123.../mytoken"
    },
    {
      "key": "amount",
      "value": "1000"
    },
    {
      "key": "from",
      "value": "neutron1from..."
    },
    {
      "key": "to",
      "value": "neutron1to..."
    }
  ]
}
```

## Parameter Events

### EventUpdateParams

Emitted when module parameters are updated through governance.

**Type:** `neutron.tokenfactory.EventUpdateParams`

**Attributes:**
- `authority` (string): Governance address that updated parameters
- `params` (string): JSON-encoded new parameters

**Example:**
```json
{
  "type": "neutron.tokenfactory.EventUpdateParams",
  "attributes": [
    {
      "key": "authority",
      "value": "neutron10d07y265gmmuvt4z0w9aw880jnsr700juxf95n"
    },
    {
      "key": "params",
      "value": "{\"denom_creation_fee\":[{\"denom\":\"untrn\",\"amount\":\"1000000\"}],\"denom_creation_gas_consume\":\"2000000\",\"fee_collector_address\":\"neutron1collector...\",\"whitelisted_hooks\":[{\"code_id\":\"1\",\"denom_creator\":\"neutron1creator...\"}]}"
    }
  ]
}
```

## Event Monitoring

### CLI Monitoring

**Monitor token creation:**
```bash
# Subscribe to token creation events
neutrond query txs --events 'neutron.tokenfactory.EventCreateDenom.creator=neutron1abc...'
```

**Monitor minting activities:**
```bash
# Monitor minting for specific token
neutrond query txs --events 'neutron.tokenfactory.EventMint.denom=factory/neutron1.../mytoken'
```

**Monitor admin changes:**
```bash
# Monitor admin changes
neutrond query txs --events 'neutron.tokenfactory.EventChangeAdmin'
```

**Monitor hook operations:**
```bash
# Monitor hook setting/removal
neutrond query txs --events 'neutron.tokenfactory.EventSetBeforeSendHook'
```

### Programmatic Monitoring

#### Go Event Listener

```go
package main

import (
    "context"
    "fmt"
    "log"
    
    "github.com/cosmos/cosmos-sdk/types"
    "github.com/tendermint/tendermint/rpc/client/http"
)

func monitorTokenFactoryEvents() {
    client, err := http.New("tcp://localhost:26657", "/websocket")
    if err != nil {
        log.Fatal(err)
    }
    
    err = client.Start()
    if err != nil {
        log.Fatal(err)
    }
    defer client.Stop()
    
    // Subscribe to token creation events
    query := "neutron.tokenfactory.EventCreateDenom.creator EXISTS"
    ch, err := client.Subscribe(context.Background(), "tokenfactory-monitor", query)
    if err != nil {
        log.Fatal(err)
    }
    
    for event := range ch {
        fmt.Printf("Token creation event: %+v\n", event.Data)
    }
}
```

#### JavaScript Event Listener

```javascript
import { Tendermint34Client } from "@cosmjs/tendermint-rpc";

async function monitorTokenFactoryEvents() {
  const client = await Tendermint34Client.connect("ws://localhost:26657/websocket");
  
  const stream = client.subscribeTx({
    "neutron.tokenfactory.EventCreateDenom.creator": "neutron1abc..."
  });
  
  for await (const event of stream) {
    console.log("Token creation event:", event);
    
    // Process creation event
    const attributes = event.events.find(e => e.type === "neutron.tokenfactory.EventCreateDenom");
    if (attributes) {
      const creator = attributes.attributes.find(a => a.key === "creator")?.value;
      const denom = attributes.attributes.find(a => a.key === "denom")?.value;
      const subdenom = attributes.attributes.find(a => a.key === "subdenom")?.value;
      
      console.log(`Token created: ${denom} by ${creator} (subdenom: ${subdenom})`);
    }
  }
}
```

### Event Analytics

#### Token Creation Analytics

```python
import json
from collections import defaultdict, Counter

def analyze_token_creation_events(events):
    """Analyze token creation patterns."""
    creator_stats = defaultdict(int)
    subdenom_patterns = Counter()
    creation_timeline = []
    
    for event in events:
        if event["type"] == "neutron.tokenfactory.EventCreateDenom":
            attrs = {attr["key"]: attr["value"] for attr in event["attributes"]}
            
            creator = attrs["creator"]
            subdenom = attrs["subdenom"]
            denom = attrs["denom"]
            
            # Count tokens per creator
            creator_stats[creator] += 1
            
            # Analyze subdenom patterns
            subdenom_patterns[len(subdenom)] += 1
            
            # Track creation timeline
            creation_timeline.append({
                "creator": creator,
                "denom": denom,
                "subdenom": subdenom,
                "timestamp": event.get("timestamp")
            })
    
    return {
        "total_tokens": len(events),
        "unique_creators": len(creator_stats),
        "tokens_per_creator": dict(creator_stats),
        "subdenom_length_distribution": dict(subdenom_patterns),
        "creation_timeline": creation_timeline
    }

# Usage
events = fetch_events_from_chain("neutron.tokenfactory.EventCreateDenom")
stats = analyze_token_creation_events(events)
print(f"Total tokens created: {stats['total_tokens']}")
print(f"Unique creators: {stats['unique_creators']}")
```

#### Supply Management Analytics

```go
func AnalyzeSupplyEvents(events []types.Event) map[string]interface{} {
    mintEvents := 0
    burnEvents := 0
    totalMinted := make(map[string]int64)
    totalBurned := make(map[string]int64)
    
    for _, event := range events {
        switch event.Type {
        case "neutron.tokenfactory.EventMint":
            mintEvents++
            for _, attr := range event.Attributes {
                if string(attr.Key) == "denom" {
                    denom := string(attr.Value)
                    // Find amount attribute
                    for _, amountAttr := range event.Attributes {
                        if string(amountAttr.Key) == "amount" {
                            amount, _ := strconv.ParseInt(string(amountAttr.Value), 10, 64)
                            totalMinted[denom] += amount
                        }
                    }
                }
            }
            
        case "neutron.tokenfactory.EventBurn":
            burnEvents++
            for _, attr := range event.Attributes {
                if string(attr.Key) == "denom" {
                    denom := string(attr.Value)
                    // Find amount attribute
                    for _, amountAttr := range event.Attributes {
                        if string(amountAttr.Key) == "amount" {
                            amount, _ := strconv.ParseInt(string(amountAttr.Value), 10, 64)
                            totalBurned[denom] += amount
                        }
                    }
                }
            }
        }
    }
    
    return map[string]interface{}{
        "mint_events": mintEvents,
        "burn_events": burnEvents,
        "total_minted": totalMinted,
        "total_burned": totalBurned,
    }
}
```

## Event Schema

### Event Structure

All Token Factory events follow the standard Cosmos SDK event format:

```protobuf
message Event {
  string type = 1;
  repeated EventAttribute attributes = 2;
}

message EventAttribute {
  bytes key = 1;
  bytes value = 2;
  bool index = 3;
}
```

### Event Types

```go
const (
    EventTypeCreateDenom       = "neutron.tokenfactory.EventCreateDenom"
    EventTypeMint             = "neutron.tokenfactory.EventMint"
    EventTypeBurn             = "neutron.tokenfactory.EventBurn"
    EventTypeChangeAdmin      = "neutron.tokenfactory.EventChangeAdmin"
    EventTypeSetDenomMetadata = "neutron.tokenfactory.EventSetDenomMetadata"
    EventTypeSetBeforeSendHook = "neutron.tokenfactory.EventSetBeforeSendHook"
    EventTypeForceTransfer    = "neutron.tokenfactory.EventForceTransfer"
    EventTypeUpdateParams     = "neutron.tokenfactory.EventUpdateParams"
)
```

## Best Practices

### Event Processing

1. **Batch Processing**: Process events in batches for efficiency
2. **Error Handling**: Implement robust error handling for event parsing
3. **Data Validation**: Validate event data before processing
4. **Idempotency**: Handle duplicate events gracefully

### Monitoring Strategy

1. **Real-time Alerts**: Set up alerts for critical events (admin changes, large mints/burns)
2. **Historical Analysis**: Store events for trend analysis
3. **Performance Metrics**: Track event processing performance
4. **Security Monitoring**: Monitor for suspicious patterns

### Event Storage

1. **Indexing**: Index events by key attributes (creator, denom, admin)
2. **Retention**: Implement appropriate data retention policies
3. **Backup**: Regularly backup event data
4. **Compression**: Use compression for historical event storage

## Security Considerations

### Event Monitoring for Security

1. **Admin Changes**: Monitor unexpected admin transfers
2. **Large Operations**: Alert on large mints/burns
3. **Hook Changes**: Track hook setting/removal events
4. **Force Transfers**: Monitor force transfer usage
5. **Parameter Changes**: Track governance parameter updates

### Anomaly Detection

1. **Unusual Patterns**: Detect unusual token creation patterns
2. **Rapid Operations**: Monitor for rapid mint/burn sequences
3. **Admin Abuse**: Detect potential admin privilege abuse
4. **Hook Bypassing**: Monitor excessive force transfer usage 