---
sidebar_position: 10
---

# Client

The Token Factory module provides comprehensive CLI commands and programmatic interfaces for creating and managing custom tokens.

## CLI Commands

### Query Commands

#### neutrond query tokenfactory params

Query the current Token Factory module parameters.

**Usage:**
```bash
neutrond query tokenfactory params [flags]
```

**Flags:**
- `--height int`: Use a specific height to query state at
- `--node string`: \<host\>:\<port\> to Tendermint RPC interface
- `--output string`: Output format (text|json)

**Examples:**

**Basic query:**
```bash
neutrond query tokenfactory params
```

**Output:**
```yaml
denom_creation_fee:
- amount: "1000000"
  denom: untrn
denom_creation_gas_consume: "2000000"
fee_collector_address: neutron1fee_collector...
whitelisted_hooks:
- code_id: "1"
  denom_creator: neutron1creator...
```

**JSON output:**
```bash
neutrond query tokenfactory params --output json
```

#### neutrond query tokenfactory denom-authority-metadata

Get the admin address for a specific token denomination.

**Usage:**
```bash
neutrond query tokenfactory denom-authority-metadata [denom] [flags]
```

**Examples:**

```bash
neutrond query tokenfactory denom-authority-metadata factory/neutron1abc.../mytoken
```

**Output:**
```yaml
authority_metadata:
  admin: neutron1admin...
```

#### neutrond query tokenfactory denoms-from-creator

Get all token denominations created by a specific address.

**Usage:**
```bash
neutrond query tokenfactory denoms-from-creator [creator] [flags]
```

**Examples:**

```bash
neutrond query tokenfactory denoms-from-creator neutron1creator...
```

**Output:**
```yaml
denoms:
- factory/neutron1creator.../token1
- factory/neutron1creator.../token2
- factory/neutron1creator.../lp-token
```

#### neutrond query tokenfactory before-send-hook

Get the before-send hook contract address for a token denomination.

**Usage:**
```bash
neutrond query tokenfactory before-send-hook [denom] [flags]
```

**Examples:**

```bash
neutrond query tokenfactory before-send-hook factory/neutron1abc.../mytoken
```

**Output:**
```yaml
contract_addr: neutron1hook_contract...
```

### Transaction Commands

#### neutrond tx tokenfactory create-denom

Create a new custom token denomination.

**Usage:**
```bash
neutrond tx tokenfactory create-denom [subdenom] [flags]
```

**Parameters:**
- `subdenom`: Custom subdenom (alphanumeric, max 44 chars)

**Flags:**
- `--from string`: Name or address of private key with which to sign
- `--gas string`: Gas limit to set per-transaction
- `--fees string`: Fees to pay along with transaction

**Examples:**

**Basic token creation:**
```bash
neutrond tx tokenfactory create-denom mytoken \
  --from creator \
  --chain-id neutron-1 \
  --gas auto \
  --fees 1000untrn
```

**With custom gas settings:**
```bash
neutrond tx tokenfactory create-denom gamecoins \
  --from creator \
  --chain-id neutron-1 \
  --gas 300000 \
  --fees 2500untrn
```

#### neutrond tx tokenfactory mint

Mint tokens to an address.

**Usage:**
```bash
neutrond tx tokenfactory mint [amount] [flags]
```

**Parameters:**
- `amount`: Amount to mint with full denomination (e.g., `1000000factory/neutron1abc.../mytoken`)

**Flags:**
- `--from string`: Name or address of private key with which to sign
- `--gas string`: Gas limit to set per-transaction
- `--fees string`: Fees to pay along with transaction

**Examples:**

**Mint tokens (mints to the sender's address):**
```bash
neutrond tx tokenfactory mint \
  1000000factory/neutron1abc.../mytoken \
  --from admin \
  --chain-id neutron-1 \
  --fees 1000untrn
```

**Note:** The mint command mints tokens to the sender's address by default. To mint to a different address, you need to use the message structure directly or use a different approach.

#### neutrond tx tokenfactory burn

Burn tokens from an address.

**Usage:**
```bash
neutrond tx tokenfactory burn [amount] [flags]
```

**Parameters:**
- `amount`: Amount to burn with full denomination (e.g., `500000factory/neutron1abc.../mytoken`)

**Flags:**
- `--from string`: Name or address of private key with which to sign
- `--gas string`: Gas limit to set per-transaction
- `--fees string`: Fees to pay along with transaction

**Examples:**

**Burn tokens (burns from the sender's address):**
```bash
neutrond tx tokenfactory burn \
  500000factory/neutron1abc.../mytoken \
  --from admin \
  --chain-id neutron-1 \
  --fees 1000untrn
```

**Note:** The burn command burns tokens from the sender's address by default. To burn from a different address, you need to use the message structure directly.

#### neutrond tx tokenfactory change-admin

Change the admin of a token denomination.

**Usage:**
```bash
neutrond tx tokenfactory change-admin [denom] [new-admin] [flags]
```

**Parameters:**
- `denom`: Token denomination
- `new-admin`: New admin address (empty string to renounce)

**Examples:**

**Transfer to new admin:**
```bash
neutrond tx tokenfactory change-admin \
  factory/neutron1abc.../mytoken \
  neutron1newadmin... \
  --from current_admin \
  --chain-id neutron-1 \
  --fees 1000untrn
```

**Renounce admin rights:**
```bash
neutrond tx tokenfactory change-admin \
  factory/neutron1abc.../mytoken \
  "" \
  --from admin \
  --chain-id neutron-1 \
  --fees 1000untrn
```

#### neutrond tx tokenfactory set-denom-metadata

Set or update token metadata using a JSON file.

**Usage:**
```bash
neutrond tx tokenfactory set-denom-metadata [metadata-file] [flags]
```

**Parameters:**
- `metadata-file`: Path to JSON file containing token metadata

**Metadata File Format:**
```json
{
  "description": "A custom token for my application",
  "denom_units": [
    {
      "denom": "factory/neutron1abc.../mytoken",
      "exponent": 0,
      "aliases": []
    },
    {
      "denom": "MCT",
      "exponent": 6,
      "aliases": []
    }
  ],
  "base": "factory/neutron1abc.../mytoken",
  "display": "MCT",
  "name": "My Custom Token",
  "symbol": "MCT",
  "uri": "",
  "uri_hash": ""
}
```

**Examples:**

**Set metadata from file:**
```bash
neutrond tx tokenfactory set-denom-metadata \
  ./token-metadata.json \
  --from admin \
  --chain-id neutron-1 \
  --fees 1000untrn
```

**Create metadata file and set:**
```bash
# Create metadata file
cat > metadata.json << EOF
{
  "description": "Company Shares Token",
  "denom_units": [
    {
      "denom": "factory/neutron1abc.../shares",
      "exponent": 0,
      "aliases": []
    },
    {
      "denom": "SHARES",
      "exponent": 0,
      "aliases": []
    }
  ],
  "base": "factory/neutron1abc.../shares",
  "display": "SHARES",
  "name": "Company Shares",
  "symbol": "SHARES"
}
EOF

# Set metadata
neutrond tx tokenfactory set-denom-metadata \
  metadata.json \
  --from admin \
  --chain-id neutron-1 \
  --fees 1000untrn
```

#### neutrond tx tokenfactory set-before-send-hook

Set or remove a before-send hook for a token.

**Usage:**
```bash
neutrond tx tokenfactory set-before-send-hook [denom] [contract-addr] [flags]
```

**Parameters:**
- `denom`: Token denomination
- `contract-addr`: Hook contract address (empty to remove)

**Examples:**

**Set hook:**
```bash
neutrond tx tokenfactory set-before-send-hook \
  factory/neutron1abc.../mytoken \
  neutron1hook_contract... \
  --from admin \
  --chain-id neutron-1 \
  --fees 1000untrn
```

**Remove hook:**
```bash
neutrond tx tokenfactory set-before-send-hook \
  factory/neutron1abc.../mytoken \
  "" \
  --from admin \
  --chain-id neutron-1 \
  --fees 1000untrn
```

#### neutrond tx tokenfactory force-transfer

Force a transfer that bypasses before-send hooks.

**Usage:**
```bash
neutrond tx tokenfactory force-transfer [amount] [from-addr] [to-addr] [flags]
```

**Parameters:**
- `amount`: Amount to transfer (with denomination)
- `from-addr`: Source address
- `to-addr`: Destination address

**Examples:**

```bash
neutrond tx tokenfactory force-transfer \
  1000factory/neutron1abc.../mytoken \
  neutron1from... \
  neutron1to... \
  --from admin \
  --chain-id neutron-1 \
  --fees 1000untrn
```

## Programmatic Clients

### Go Client

```go
package main

import (
    "context"
    "fmt"
    "log"
    
    "github.com/cosmos/cosmos-sdk/client"
    "github.com/cosmos/cosmos-sdk/client/tx"
    "github.com/cosmos/cosmos-sdk/crypto/keyring"
    sdk "github.com/cosmos/cosmos-sdk/types"
    "github.com/neutron-org/neutron/v6/x/tokenfactory/types"
)

type TokenFactoryClient struct {
    clientCtx  client.Context
    queryClient types.QueryClient
    keyring    keyring.Keyring
}

func NewTokenFactoryClient(clientCtx client.Context) *TokenFactoryClient {
    return &TokenFactoryClient{
        clientCtx:   clientCtx,
        queryClient: types.NewQueryClient(clientCtx),
        keyring:     clientCtx.Keyring,
    }
}

// Query Methods

func (c *TokenFactoryClient) GetParams(ctx context.Context) (*types.Params, error) {
    resp, err := c.queryClient.Params(ctx, &types.QueryParamsRequest{})
    if err != nil {
        return nil, err
    }
    return &resp.Params, nil
}

func (c *TokenFactoryClient) GetDenomAdmin(ctx context.Context, denom string) (string, error) {
    resp, err := c.queryClient.DenomAuthorityMetadata(ctx, &types.QueryDenomAuthorityMetadataRequest{
        Denom: denom,
    })
    if err != nil {
        return "", err
    }
    return resp.AuthorityMetadata.Admin, nil
}

func (c *TokenFactoryClient) GetDenomsByCreator(ctx context.Context, creator string) ([]string, error) {
    resp, err := c.queryClient.DenomsFromCreator(ctx, &types.QueryDenomsFromCreatorRequest{
        Creator: creator,
    })
    if err != nil {
        return nil, err
    }
    return resp.Denoms, nil
}

func (c *TokenFactoryClient) GetBeforeSendHook(ctx context.Context, denom string) (string, error) {
    resp, err := c.queryClient.BeforeSendHookAddress(ctx, &types.QueryBeforeSendHookAddressRequest{
        Denom: denom,
    })
    if err != nil {
        return "", err
    }
    return resp.ContractAddr, nil
}

// Transaction Methods

func (c *TokenFactoryClient) CreateDenom(keyName, subdenom string) (*sdk.TxResponse, error) {
    keyInfo, err := c.keyring.Key(keyName)
    if err != nil {
        return nil, err
    }
    
    creatorAddr := sdk.AccAddress(keyInfo.GetPubKey().Address())
    
    msg := &types.MsgCreateDenom{
        Sender:   creatorAddr.String(),
        Subdenom: subdenom,
    }
    
    return c.broadcastTx(keyName, msg)
}

func (c *TokenFactoryClient) Mint(keyName, amount, denom, mintToAddr string) (*sdk.TxResponse, error) {
    keyInfo, err := c.keyring.Key(keyName)
    if err != nil {
        return nil, err
    }
    
    senderAddr := sdk.AccAddress(keyInfo.GetPubKey().Address())
    
    coin, err := sdk.ParseCoinNormalized(amount + denom)
    if err != nil {
        return nil, err
    }
    
    msg := &types.MsgMint{
        Sender:        senderAddr.String(),
        Amount:        coin,
        MintToAddress: mintToAddr,
    }
    
    return c.broadcastTx(keyName, msg)
}

func (c *TokenFactoryClient) Burn(keyName, amount, denom, burnFromAddr string) (*sdk.TxResponse, error) {
    keyInfo, err := c.keyring.Key(keyName)
    if err != nil {
        return nil, err
    }
    
    senderAddr := sdk.AccAddress(keyInfo.GetPubKey().Address())
    
    coin, err := sdk.ParseCoinNormalized(amount + denom)
    if err != nil {
        return nil, err
    }
    
    msg := &types.MsgBurn{
        Sender:          senderAddr.String(),
        Amount:          coin,
        BurnFromAddress: burnFromAddr,
    }
    
    return c.broadcastTx(keyName, msg)
}

func (c *TokenFactoryClient) ChangeAdmin(keyName, denom, newAdmin string) (*sdk.TxResponse, error) {
    keyInfo, err := c.keyring.Key(keyName)
    if err != nil {
        return nil, err
    }
    
    senderAddr := sdk.AccAddress(keyInfo.GetPubKey().Address())
    
    msg := &types.MsgChangeAdmin{
        Sender:   senderAddr.String(),
        Denom:    denom,
        NewAdmin: newAdmin,
    }
    
    return c.broadcastTx(keyName, msg)
}

func (c *TokenFactoryClient) SetBeforeSendHook(keyName, denom, contractAddr string) (*sdk.TxResponse, error) {
    keyInfo, err := c.keyring.Key(keyName)
    if err != nil {
        return nil, err
    }
    
    senderAddr := sdk.AccAddress(keyInfo.GetPubKey().Address())
    
    msg := &types.MsgSetBeforeSendHook{
        Sender:       senderAddr.String(),
        Denom:        denom,
        ContractAddr: contractAddr,
    }
    
    return c.broadcastTx(keyName, msg)
}

func (c *TokenFactoryClient) broadcastTx(keyName string, msg sdk.Msg) (*sdk.TxResponse, error) {
    txBuilder := c.clientCtx.TxConfig.NewTxBuilder()
    
    err := txBuilder.SetMsgs(msg)
    if err != nil {
        return nil, err
    }
    
    // Set gas and fees
    txBuilder.SetGasLimit(300000)
    txBuilder.SetFeeAmount(sdk.NewCoins(sdk.NewCoin("untrn", sdk.NewInt(1000))))
    
    // Sign transaction
    err = tx.Sign(c.clientCtx.TxConfig, keyName, txBuilder, true)
    if err != nil {
        return nil, err
    }
    
    // Broadcast transaction
    txBytes, err := c.clientCtx.TxConfig.TxEncoder()(txBuilder.GetTx())
    if err != nil {
        return nil, err
    }
    
    return c.clientCtx.BroadcastTx(txBytes)
}

// Utility Methods

func (c *TokenFactoryClient) IsTokenAdmin(ctx context.Context, denom, address string) (bool, error) {
    admin, err := c.GetDenomAdmin(ctx, denom)
    if err != nil {
        return false, err
    }
    return admin == address, nil
}

func (c *TokenFactoryClient) GetTokenInfo(ctx context.Context, denom string) (map[string]interface{}, error) {
    info := make(map[string]interface{})
    
    // Check if it's a factory token
    if !sdk.ValidateDenom(denom) || !strings.HasPrefix(denom, "factory/") {
        info["is_factory"] = false
        return info, nil
    }
    
    info["is_factory"] = true
    info["denom"] = denom
    
    // Get admin
    admin, err := c.GetDenomAdmin(ctx, denom)
    if err != nil {
        return nil, err
    }
    info["admin"] = admin
    
    // Get hook (if any)
    hook, err := c.GetBeforeSendHook(ctx, denom)
    if err == nil && hook != "" {
        info["hook"] = hook
    }
    
    return info, nil
}

// Usage example
func main() {
    // Initialize client context
    clientCtx := client.Context{
        // Configure with your chain settings
    }
    
    client := NewTokenFactoryClient(clientCtx)
    ctx := context.Background()
    
    // Create a token
    resp, err := client.CreateDenom("creator", "mytoken")
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("Token created: %s\n", resp.TxHash)
    
    // Get created denoms
    denoms, err := client.GetDenomsByCreator(ctx, "neutron1creator...")
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("Created denoms: %v\n", denoms)
    
    // Mint tokens
    denom := denoms[0]
    resp, err = client.Mint("creator", "1000000", denom, "neutron1recipient...")
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("Tokens minted: %s\n", resp.TxHash)
}
```

### JavaScript/TypeScript Client

```typescript
import { SigningCosmWasmClient, CosmWasmClient } from "@cosmjs/cosmwasm-stargate";
import { DirectSecp256k1HdWallet } from "@cosmjs/proto-signing";
import { GasPrice } from "@cosmjs/stargate";

interface TokenFactoryParams {
  denom_creation_fee: Array<{ denom: string; amount: string }>;
  denom_creation_gas_consume: string;
  fee_collector_address: string;
  whitelisted_hooks: Array<{
    code_id: string;
    denom_creator: string;
  }>;
}

export class TokenFactoryClient {
  private client: SigningCosmWasmClient;
  private queryClient: CosmWasmClient;
  private address: string;

  constructor(client: SigningCosmWasmClient, queryClient: CosmWasmClient, address: string) {
    this.client = client;
    this.queryClient = queryClient;
    this.address = address;
  }

  static async connect(
    rpcEndpoint: string,
    mnemonic: string,
    prefix: string = "neutron"
  ): Promise<TokenFactoryClient> {
    const wallet = await DirectSecp256k1HdWallet.fromMnemonic(mnemonic, { prefix });
    const [{ address }] = await wallet.getAccounts();

    const gasPrice = GasPrice.fromString("0.025untrn");
    const client = await SigningCosmWasmClient.connectWithSigner(rpcEndpoint, wallet, { gasPrice });
    const queryClient = await CosmWasmClient.connect(rpcEndpoint);

    return new TokenFactoryClient(client, queryClient, address);
  }

  // Query Methods

  async getParams(): Promise<TokenFactoryParams> {
    const response = await this.queryClient.queryContractSmart(
      "neutron1...", // Module query contract address
      { params: {} }
    );
    return response.params;
  }

  async getDenomAdmin(denom: string): Promise<string> {
    const response = await this.queryClient.queryContractSmart(
      "neutron1...", // Module query contract address
      { denom_authority_metadata: { denom } }
    );
    return response.authority_metadata.admin;
  }

  async getDenomsByCreator(creator: string): Promise<string[]> {
    const response = await this.queryClient.queryContractSmart(
      "neutron1...", // Module query contract address
      { denoms_from_creator: { creator } }
    );
    return response.denoms;
  }

  async getBeforeSendHook(denom: string): Promise<string | null> {
    try {
      const response = await this.queryClient.queryContractSmart(
        "neutron1...", // Module query contract address
        { before_send_hook_address: { denom } }
      );
      return response.contract_addr || null;
    } catch {
      return null;
    }
  }

  // Transaction Methods

  async createDenom(subdenom: string): Promise<string> {
    const msg = {
      typeUrl: "/neutron.tokenfactory.MsgCreateDenom",
      value: {
        sender: this.address,
        subdenom: subdenom,
      },
    };

    const result = await this.client.signAndBroadcast(this.address, [msg], "auto");
    return result.transactionHash;
  }

  async mint(amount: string, denom: string, mintToAddress: string): Promise<string> {
    const msg = {
      typeUrl: "/neutron.tokenfactory.MsgMint",
      value: {
        sender: this.address,
        amount: { denom, amount },
        mintToAddress: mintToAddress,
      },
    };

    const result = await this.client.signAndBroadcast(this.address, [msg], "auto");
    return result.transactionHash;
  }

  async burn(amount: string, denom: string, burnFromAddress: string): Promise<string> {
    const msg = {
      typeUrl: "/neutron.tokenfactory.MsgBurn",
      value: {
        sender: this.address,
        amount: { denom, amount },
        burnFromAddress: burnFromAddress,
      },
    };

    const result = await this.client.signAndBroadcast(this.address, [msg], "auto");
    return result.transactionHash;
  }

  async changeAdmin(denom: string, newAdmin: string): Promise<string> {
    const msg = {
      typeUrl: "/neutron.tokenfactory.MsgChangeAdmin",
      value: {
        sender: this.address,
        denom: denom,
        newAdmin: newAdmin,
      },
    };

    const result = await this.client.signAndBroadcast(this.address, [msg], "auto");
    return result.transactionHash;
  }

  async setDenomMetadata(
    denom: string,
    metadata: {
      name: string;
      symbol: string;
      description: string;
      decimals: number;
      logoUrl?: string;
      website?: string;
    }
  ): Promise<string> {
    const msg = {
      typeUrl: "/neutron.tokenfactory.MsgSetDenomMetadata",
      value: {
        sender: this.address,
        metadata: {
          description: metadata.description,
          denomUnits: [
            {
              denom: denom,
              exponent: 0,
              aliases: [],
            },
            {
              denom: metadata.symbol.toLowerCase(),
              exponent: metadata.decimals,
              aliases: [],
            },
          ],
          base: denom,
          display: metadata.symbol.toLowerCase(),
          name: metadata.name,
          symbol: metadata.symbol,
          uri: metadata.logoUrl || "",
          uriHash: "",
        },
      },
    };

    const result = await this.client.signAndBroadcast(this.address, [msg], "auto");
    return result.transactionHash;
  }

  async setBeforeSendHook(denom: string, contractAddr: string): Promise<string> {
    const msg = {
      typeUrl: "/neutron.tokenfactory.MsgSetBeforeSendHook",
      value: {
        sender: this.address,
        denom: denom,
        contractAddr: contractAddr,
      },
    };

    const result = await this.client.signAndBroadcast(this.address, [msg], "auto");
    return result.transactionHash;
  }

  async forceTransfer(
    amount: string,
    denom: string,
    fromAddress: string,
    toAddress: string
  ): Promise<string> {
    const msg = {
      typeUrl: "/neutron.tokenfactory.MsgForceTransfer",
      value: {
        sender: this.address,
        amount: { denom, amount },
        transferFromAddress: fromAddress,
        transferToAddress: toAddress,
      },
    };

    const result = await this.client.signAndBroadcast(this.address, [msg], "auto");
    return result.transactionHash;
  }

  // Utility Methods

  async isTokenAdmin(denom: string, address: string): Promise<boolean> {
    try {
      const admin = await this.getDenomAdmin(denom);
      return admin === address;
    } catch {
      return false;
    }
  }

  async getTokenInfo(denom: string): Promise<{
    isFactory: boolean;
    admin?: string;
    hook?: string;
    denom: string;
  }> {
    const isFactory = denom.startsWith("factory/");
    
    if (!isFactory) {
      return { isFactory: false, denom };
    }

    const admin = await this.getDenomAdmin(denom);
    const hook = await this.getBeforeSendHook(denom);

    return {
      isFactory: true,
      admin,
      hook: hook || undefined,
      denom,
    };
  }

  async createAndSetupToken(
    subdenom: string,
    metadata: {
      name: string;
      symbol: string;
      description: string;
      decimals: number;
    },
    initialMint?: { amount: string; recipient: string }
  ): Promise<{
    denom: string;
    createTxHash: string;
    metadataTxHash: string;
    mintTxHash?: string;
  }> {
    // Create token
    const createTxHash = await this.createDenom(subdenom);
    
    // Generate full denom
    const denom = `factory/${this.address}/${subdenom}`;
    
    // Set metadata
    const metadataTxHash = await this.setDenomMetadata(denom, metadata);
    
    // Mint initial supply if specified
    let mintTxHash: string | undefined;
    if (initialMint) {
      mintTxHash = await this.mint(initialMint.amount, denom, initialMint.recipient);
    }

    return {
      denom,
      createTxHash,
      metadataTxHash,
      mintTxHash,
    };
  }
}

// Usage example
async function example() {
  const client = await TokenFactoryClient.connect(
    "https://rpc.neutron.org",
    "your mnemonic here"
  );

  // Create and setup a token
  const result = await client.createAndSetupToken(
    "mytoken",
    {
      name: "My Custom Token",
      symbol: "MCT",
      description: "A custom token for my application",
      decimals: 6,
    },
    {
      amount: "1000000000000", // 1M tokens with 6 decimals
      recipient: client.address,
    }
  );

  console.log("Token created:", result.denom);
  console.log("Create TX:", result.createTxHash);
  console.log("Metadata TX:", result.metadataTxHash);
  console.log("Mint TX:", result.mintTxHash);

  // Get token info
  const info = await client.getTokenInfo(result.denom);
  console.log("Token info:", info);
}
```

## CLI Utilities and Scripts

### Batch Operations Script

```bash
#!/bin/bash

# batch_token_operations.sh - Batch token operations script

CHAIN_ID="neutron-1"
NODE="https://rpc.neutron.org:443"
KEY_NAME="admin"
FEES="1000untrn"

# Function to create multiple tokens
create_tokens() {
    local subdenoms=("$@")
    
    echo "Creating ${#subdenoms[@]} tokens..."
    
    for subdenom in "${subdenoms[@]}"; do
        echo "Creating token: $subdenom"
        neutrond tx tokenfactory create-denom "$subdenom" \
            --from "$KEY_NAME" \
            --chain-id "$CHAIN_ID" \
            --node "$NODE" \
            --gas auto \
            --fees "$FEES" \
            --yes
        
        sleep 6  # Wait for transaction confirmation
    done
}

# Function to set metadata for multiple tokens
set_metadata_batch() {
    local creator="$1"
    shift
    local -A metadata=()
    
    # Parse metadata arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --subdenom)
                current_subdenom="$2"
                shift 2
                ;;
            --name)
                metadata["$current_subdenom,name"]="$2"
                shift 2
                ;;
            --symbol)
                metadata["$current_subdenom,symbol"]="$2"
                shift 2
                ;;
            --description)
                metadata["$current_subdenom,description"]="$2"
                shift 2
                ;;
            --decimals)
                metadata["$current_subdenom,decimals"]="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done
    
    # Set metadata for each token
    for key in "${!metadata[@]}"; do
        if [[ $key == *",name" ]]; then
            subdenom="${key%,name}"
            denom="factory/$creator/$subdenom"
            
            echo "Setting metadata for: $denom"
            neutrond tx tokenfactory set-denom-metadata "$denom" \
                --name "${metadata["$subdenom,name"]}" \
                --symbol "${metadata["$subdenom,symbol"]}" \
                --description "${metadata["$subdenom,description"]}" \
                --decimals "${metadata["$subdenom,decimals"]}" \
                --from "$KEY_NAME" \
                --chain-id "$CHAIN_ID" \
                --node "$NODE" \
                --gas auto \
                --fees "$FEES" \
                --yes
            
            sleep 6
        fi
    done
}

# Function to mint to multiple recipients
mint_batch() {
    local denom="$1"
    local amount="$2"
    shift 2
    local recipients=("$@")
    
    echo "Minting $amount $denom to ${#recipients[@]} recipients..."
    
    for recipient in "${recipients[@]}"; do
        echo "Minting to: $recipient"
        neutrond tx tokenfactory mint "$amount$denom" "$recipient" \
            --from "$KEY_NAME" \
            --chain-id "$CHAIN_ID" \
            --node "$NODE" \
            --gas auto \
            --fees "$FEES" \
            --yes
        
        sleep 6
    done
}

# Usage examples:
# ./batch_token_operations.sh create token1 token2 token3
# ./batch_token_operations.sh metadata neutron1creator... --subdenom token1 --name "Token 1" --symbol "TK1" --description "First token" --decimals 6
# ./batch_token_operations.sh mint factory/neutron1.../token1 1000000 neutron1addr1... neutron1addr2... neutron1addr3...

case "$1" in
    create)
        shift
        create_tokens "$@"
        ;;
    metadata)
        shift
        set_metadata_batch "$@"
        ;;
    mint)
        shift
        mint_batch "$@"
        ;;
    *)
        echo "Usage: $0 {create|metadata|mint} [args...]"
        exit 1
        ;;
esac
```

### Token Information Script

```bash
#!/bin/bash

# token_info.sh - Get comprehensive token information

get_token_info() {
    local denom="$1"
    
    echo "=== Token Information: $denom ==="
    echo
    
    # Check if it's a factory token
    if [[ ! $denom == factory/* ]]; then
        echo "Not a factory token"
        return 1
    fi
    
    # Get admin
    echo "Admin:"
    neutrond query tokenfactory denom-authority-metadata "$denom" --output json | jq -r '.authority_metadata.admin'
    echo
    
    # Get metadata
    echo "Metadata:"
    neutrond query bank denom-metadata "$denom" --output json | jq '.metadata // "No metadata set"'
    echo
    
    # Get hook
    echo "Before-send hook:"
    hook=$(neutrond query tokenfactory before-send-hook "$denom" --output json 2>/dev/null | jq -r '.contract_addr // "No hook set"')
    echo "$hook"
    echo
    
    # Get total supply
    echo "Total supply:"
    neutrond query bank total --denom "$denom" --output json | jq -r '.amount.amount // "0"'
    echo
    
    # Extract creator from denom
    creator=$(echo "$denom" | sed 's/factory\/\([^/]*\)\/.*/\1/')
    echo "Creator: $creator"
    
    # Get all denoms by creator
    echo
    echo "All tokens by creator:"
    neutrond query tokenfactory denoms-from-creator "$creator" --output json | jq -r '.denoms[]'
}

# Usage: ./token_info.sh factory/neutron1.../mytoken
get_token_info "$1"
```

## Best Practices

### CLI Usage

1. **Gas Estimation**: Always use `--gas auto` for optimal gas usage
2. **Fee Calculation**: Set appropriate fees based on network conditions
3. **Transaction Confirmation**: Wait for confirmation before subsequent operations
4. **Error Handling**: Check transaction results before proceeding
5. **Batch Operations**: Group related operations to save time

### Security

1. **Key Management**: Use hardware wallets or secure key storage
2. **Admin Verification**: Always verify admin addresses before operations
3. **Hook Validation**: Only use audited, trusted hook contracts
4. **Metadata Accuracy**: Provide complete, accurate token information
5. **Testing**: Test all operations on testnet first

### Performance

1. **Parallel Operations**: Use parallel execution for independent operations
2. **Connection Pooling**: Reuse client connections when possible
3. **Caching**: Cache frequently accessed data
4. **Rate Limiting**: Respect node rate limits
5. **Error Retry**: Implement exponential backoff for retries

### Monitoring

1. **Transaction Tracking**: Monitor transaction status and confirmations
2. **Event Watching**: Subscribe to relevant events for real-time updates
3. **Balance Monitoring**: Track token balances and supply changes
4. **Error Logging**: Log errors for debugging and analysis
5. **Performance Metrics**: Track operation latency and success rates 